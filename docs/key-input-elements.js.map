{"version":3,"sources":["webpack:///webpack/bootstrap 788c568532a408da8fc5","webpack:///./src/key-input-registerer.js","webpack:///./src/key-input.js"],"names":[],"mappings":"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","file":"key-input-elements.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 788c568532a408da8fc5","import * as ki from \"./key-input\";\n\nki.register();\n\n\n\n// WEBPACK FOOTER //\n// ./src/key-input-registerer.js","declare interface KeyInput extends HTMLInputElement {\n  allowModOnly: boolean;\n  noMod: boolean;\n  ignore: ?RegExp;\n}\nexport interface KeyupInput extends KeyInput {}\nexport interface KeydownInput extends KeyInput {}\n\nfunction mixinKeyInput<T: HTMLInputElement>(c: Class<T>): Class<T & KeyInput> {\n  // $FlowFixMe Force cast to returned type\n  return class extends c {\n    get allowModOnly(): boolean { return this.hasAttribute(\"allow-mod-only\"); }\n    set allowModOnly(b: boolean): void { markAttr(this, \"allow-mod-only\", b); }\n\n    get noMod(): boolean { return this.hasAttribute(\"no-mod\"); }\n    set noMod(b: boolean): void { markAttr(this, \"no-mod\", b); }\n\n    get ignore(): ?RegExp {\n      const v = this.getAttribute(\"ignore\");\n      return v == null ? null : new RegExp(v);\n    }\n    set ignore(pattern: ?RegExp): void {\n      if (pattern != null) this.setAttribute(\"ignore\", pattern.toString());\n    }\n\n    get value(): string { return super.value; }\n    set value(v: string): void {\n      super.value = v;\n      this.select();\n    }\n\n    constructor() {\n      super();\n    }\n\n    createdCallback() {\n      this.type = \"text\";\n      this.addEventListener(\"keypress\", (ev: KeyboardEvent) => ev.preventDefault(), true);\n      this.addEventListener(\"focus\", () => this.select());\n    }\n\n    attachedCallback() {}\n\n    static get observedAttributes() { return [\"type\"]; }\n    attributeChangedCallback(attrName: string) {\n      switch (attrName) {\n      case \"type\":\n        this.type = \"text\";\n        break;\n      }\n    }\n\n    buildMatcher(): EventMatcher {\n      return new EventMatcher(this.value, generateOptions(this));\n    }\n  };\n}\n\nexport function mixinKeydownInput<T: HTMLInputElement>(c: Class<T>): Class<T & KeydownInput> {\n  // $FlowFixMe Force cast to returned type\n  return class extends mixinKeyInput(c) {\n    constructor() {\n      super();\n    }\n\n    createdCallback() {\n      super.createdCallback();\n      this.addEventListener(\"keydown\", (e: KeyboardEvent) => handleEvent(this, e));\n    }\n  };\n}\n\nexport class KeydownInputElement extends mixinKeydownInput(HTMLInputElement) {\n  static get extends() { return \"input\"; }\n}\n\nexport function mixinKeyupInput<T: HTMLInputElement>(c: Class<T>): Class<T & KeyupInput> {\n  // $FlowFixMe Force cast to returned type\n  return class extends mixinKeyInput(c) {\n    constructor() {\n      super();\n    }\n\n    createdCallback() {\n      super.createdCallback();\n      this.addEventListener(\"keyup\", (e: KeyboardEvent) => handleEvent(this, e));\n    }\n  };\n}\n\nexport class KeyupInputElement extends mixinKeyupInput(HTMLInputElement) {\n  static get extends() { return \"input\"; }\n}\n\nexport function register() {\n  document.registerElement(\"keydown-input\", KeydownInputElement);\n  document.registerElement(\"keyup-input\", KeyupInputElement);\n}\n\n//\n\ninterface EventMatcherOptions {\n  allowModOnly?: boolean;\n  noMod?: boolean;\n  ignore?: ?RegExp;\n}\n\nconst DEFAULT_OPTIONS = {\n  allowModOnly: false,\n  noMod: false,\n  ignore: undefined,\n};\n\nclass EventMatcher {\n  pattern: string;\n  options: EventMatcherOptions;\n\n  constructor(pattern: string, options?: EventMatcherOptions = DEFAULT_OPTIONS) {\n    this.pattern = pattern;\n    this.options = options;\n  }\n\n  test(event: Event) {\n    if (!(event instanceof KeyboardEvent)) return false;\n    if (this.pattern.length === 0) return false;\n    const value = buildValue((event: KeyboardEvent), this.options);\n    return this.pattern === value;\n  }\n}\n\n//\n\nfunction generateOptions(self: KeyInput): EventMatcherOptions {\n  const o: any = {};\n  for (const [name, defaultValue] of Object.entries(DEFAULT_OPTIONS)) {\n    const value = (self: any)[name];\n    o[name] = value == null ? defaultValue : value;\n  }\n  return o;\n}\n\nfunction handleEvent(self: KeyInput, event: KeyboardEvent) {\n  if (self.readOnly) return;\n  const v = buildValue(event, self);\n  console.log(event);\n  if (v != null) self.value = v;\n  if (v) event.preventDefault();\n}\n\nconst MOD_KEYS = new Set([\"Shift\", \"Alt\", \"Control\", \"Meta\"]);\n\nfunction buildValue(event: KeyboardEvent, options: EventMatcherOptions): ?string {\n  const code = event.code;\n  if (!options.allowModOnly && isModKey(event.key)) {\n    return null;\n  }\n\n  let value;\n  if (options.noMod) {\n    value = code;\n  } else {\n    const a = [code];\n    if (event.shiftKey && !code.startsWith(\"Shift\"))   a.unshift(\"Shift\");\n    if (event.altKey   && !code.startsWith(\"Alt\"))     a.unshift(\"Alt\");\n    if (event.ctrlKey  && !code.startsWith(\"Control\")) a.unshift(\"Control\");\n    if (event.metaKey  && !code.startsWith(\"Meta\"))    a.unshift(\"Meta\");\n    value = a.join(\" + \");\n  }\n\n  const ignore = options.ignore;\n  if (ignore && ignore.test(value)) {\n    return null;\n  }\n  return value;\n}\n\nfunction isModKey(key: string): boolean {\n  return MOD_KEYS.has(key);\n}\n\nfunction markAttr(self: HTMLElement, name: string, b: boolean): void {\n  if (b) {\n    self.setAttribute(name, \"\");\n  } else {\n    self.removeAttribute(name);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/key-input.js"],"sourceRoot":""}